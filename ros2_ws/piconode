# Copyright 2016 Open Source Robotics Foundation, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import rclpy
from rclpy.node import Node
from std_msgs.msg import String, Float32
from threading import Lock, Thread
import serial
import math

class RobotState:
    def __init__(self):
        self._lock = Lock()
        self.temperature = 0.0  # °C
        self.pressure = 0.0     # hPa
        self.acceleration = 0.0 # ft/s² (magnitude)
        self.altitude = 0.0     # ft
        self.wrist_position = 0.0
        self.lower_elbow_position = 0.0
        self.upper_elbow_position = 0.0
        self.claw_position = 0.0
        self.last_command = None

    def update_sensor(self, sensor_type, value):
        with self._lock:
            setattr(self, sensor_type, value)

    def update_motor(self, motor_type, value):
        with self._lock:
            setattr(self, motor_type, value)

    def get_sensor(self, sensor_type):
        with self._lock:
            return getattr(self, sensor_type)

    def get_motor(self, motor_type):
        with self._lock:
            return getattr(self, motor_type)

    def update_command(self, command):
        with self._lock:
            self.last_command = command

    def get_command(self):
        with self._lock:
            return self.last_command

class RobotNode(Node):
    def __init__(self):
        super().__init__('robot_node')
        self.state = RobotState()

        # Initialize publishers
        self.pub_temperature = self.create_publisher(Float32, 'temperature', 10)
        self.pub_pressure = self.create_publisher(Float32, 'pressure', 10)
        self.pub_altitude = self.create_publisher(Float32, 'altitude', 10)
        self.pub_acceleration = self.create_publisher(Float32, 'acceleration', 10)

        # Initialize subscription
        self.subscription = self.create_subscription(
            String, 'command', self.command_callback, 10)

        # Initialize serial connection
        self.serial = None
        try:
            self.serial = serial.Serial('/dev/ttyUSB0', 9600, timeout=1)
            self.get_logger().info('Serial connection established')
        except serial.SerialException as e:
            self.get_logger().error(f"Serial connection failed: {e}")

        # Timers
        self.create_timer(1.0, self.publish_sensors)  # Publish sensors every 1 second (from picotalker)
        self.create_timer(0.1, self.log_command)      # Log commands every 0.1 seconds (from picolistener)

        # Start serial reading thread
        self.serial_thread = Thread(target=self.read_serial)
        self.serial_thread.daemon = True
        self.serial_thread.start()

        self.get_logger().info('Robot Node initialized, listening for commands and publishing sensor data')

    def command_callback(self, msg):
        # Store command
        self.state.update_command(msg.data)
        self.get_logger().info(f'Received command: "{msg.data}"')

        # Parse command (expected format: C{claw}:W{wrist}:U{upper_elbow}:L{lower_elbow}:T{turret})
        try:
            parts = msg.data.split(':')
            if len(parts) != 5:
                self.get_logger().error(f"Invalid command format: {msg.data}")
                return
            claw = float(parts[0][1:])  # Skip 'C'
            wrist = float(parts[1][1:])  # Skip 'W'
            upper_elbow = float(parts[2][1:])  # Skip 'U'
            lower_elbow = float(parts[3][1:])  # Skip 'L'
            turret = float(parts[4][1:])  # Skip 'T'

            # Update motor positions
            if claw != 0.0:
                self.state.update_motor('claw_position', self.state.get_motor('claw_position') + claw)
                if self.serial and self.serial.is_open:
                    command = f"moveaxis1,{claw}\n"
                    self.serial.write(command.encode())
                    self.get_logger().info(f'Sent serial command: {command.strip()}')
            if wrist != 0.0:
                self.state.update_motor('wrist_position', self.state.get_motor('wrist_position') + wrist)
                if self.serial and self.serial.is_open:
                    command = f"moveaxis2,{wrist}\n"
                    self.serial.write(command.encode())
                    self.get_logger().info(f'Sent serial command: {command.strip()}')
            if upper_elbow != 0.0:
                self.state.update_motor('upper_elbow_position', self.state.get_motor('upper_elbow_position') + upper_elbow)
                if self.serial and self.serial.is_open:
                    command = f"moveaxis3,{upper_elbow}\n"
                    self.serial.write(command.encode())
                    self.get_logger().info(f'Sent serial command: {command.strip()}')
            if lower_elbow != 0.0:
                self.state.update_motor('lower_elbow_position', self.state.get_motor('lower_elbow_position') + lower_elbow)
                if self.serial and self.serial.is_open:
                    command = f"moveaxis4,{lower_elbow}\n"
                    self.serial.write(command.encode())
                    self.get_logger().info(f'Sent serial command: {command.strip()}')
            if turret != 0.0:
                self.get_logger().warn('Turret command received but no turret servo defined on Pico')
        except (ValueError, serial.SerialException) as e:
            self.get_logger().error(f"Failed to process command: {msg.data} ({e})")

    def read_serial(self):
        while True:
            if self.serial and self.serial.is_open:
                try:
                    line = self.serial.readline().decode('utf-8').strip()
                    if not line:
                        continue
                    # Parse sensor data from Pico serial output
                    if line.startswith('Temperature = '):
                        temp = float(line.split(' ')[2])
                        self.state.update_sensor('temperature', temp)
                    elif line.startswith('Pressure = '):
                        pressure = float(line.split(' ')[2])
                        self.state.update_sensor('pressure', pressure)
                    elif line.startswith('Approx. Altitude = '):
                        altitude_m = float(line.split(' ')[3])
                        altitude_ft = altitude_m * 3.28084  # Convert meters to feet
                        self.state.update_sensor('altitude', altitude_ft)
                    elif line.startswith('Accl:'):
                        parts = line[5:].split(', ')
                        if len(parts) == 3:
                            x, y, z = map(float, parts)
                            # Convert m/s² to ft/s² and compute magnitude
                            accel_ft_s2 = math.sqrt(x**2 + y**2 + z**2) * 3.28084
                            self.state.update_sensor('acceleration', accel_ft_s2)
                except (ValueError, UnicodeDecodeError, serial.SerialException) as e:
                    self.get_logger().error(f"Failed to parse serial data: {line} ({e})")

    def publish_sensors(self):
        # Publish sensor data
        msg = Float32()
        msg.data = self.state.get_sensor('temperature')
        self.pub_temperature.publish(msg)
        self.get_logger().info(f'Published temperature: {msg.data}')

        msg.data = self.state.get_sensor('pressure')
        self.pub_pressure.publish(msg)
        self.get_logger().info(f'Published pressure: {msg.data}')

        msg.data = self.state.get_sensor('altitude')
        self.pub_altitude.publish(msg)
        self.get_logger().info(f'Published altitude: {msg.data}')

        msg.data = self.state.get_sensor('acceleration')
        self.pub_acceleration.publish(msg)
        self.get_logger().info(f'Published acceleration: {msg.data}')

    def log_command(self):
        # Log last command (from picolistener)
        command = self.state.get_command()
        if command is not None:
            self.get_logger().info(f'Last stored command: "{command}"')

    def destroy_node(self):
        if self.serial and self.serial.is_open:
            self.serial.close()
            self.get_logger().info('Serial connection closed')
        super().destroy_node()

def main(args=None):
    rclpy.init(args=args)
    robot_node = RobotNode()
    try:
        rclpy.spin(robot_node)
    except KeyboardInterrupt:
        pass
    finally:
        robot_node.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
